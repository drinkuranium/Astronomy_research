# 2020-02-07, Dong Uk Kim, add_gas.py
# This program adds gas particles to initial galxies generated by GalIC

import numpy as np
import numpy.random as nprand
import h5py
import matplotlib.pyplot as plt
import os
import sys
from scipy.optimize import brentq
from load_from_snapshot import load_from_snapshot


Y = 0.24  ## Helium fraction

## mu is extracted from GIZMO running test, to make T=10000K
mu = 0.5889076650588833 ## Mean molecular number

gamma = 5./3.  ## Heat capacity ratio
m_p = 1.67e-27/1.9885e40  ## In code unit (1e10 solar mass)
k = 1.38e-23/1.9885e40*(3.0857e16/3.0856e19)**2  ## In code unit (1e10 solar amss, kpc, Gyr)


def R_PDF_integrated(R, R0):
    """Probability density function of R. R0: radial scale length."""
    return 1-(1+R/R0)*np.exp(-R/R0)


def R_PDF_integrated_inverse(R0, R_seed):
    """Compute inverse of given value of R_PDF_integrated.

    Arguments:
      R0 (float): Disk radial scale length

      R_seed (1D ndarray): Array of randomly generated seed numbers with
        length=ngas. 0<=Each compontnent<1.

    Returns:
      R_list (1D ndarray): R coordinate values corresponding to R_seed
    """

    R_list = np.array([])
    for R_seed_one in R_seed:
        R = brentq((lambda R: 1-R_PDF_integrated(R, R0)-R_seed_one), 0, 1e10)
        R_list = np.append(R_list, R)
    return R_list

def z_scale_height(R, z0):
    """Scale height h_z as a function of radius in code unit."""
    return z0/2


def z_PDF_integrated_inverse(R, z0, z_seed):
    """Inverse of integrated probability density function of z.

    Arguments:
      R (float): Radius

      z_seed (float): Randomly generated seed number. 0 <=z_ssed <1.

      z0 (float): Disk scale height

    Returns:
      z (float): z-axis value corresponding to z_seed
    """

    z = -z_scale_height(R, z0)*np.log(z_seed)
    return z

def generate_gas(sdir, snum, ngas, gas_frac, T_gas):
    """Generate gas particles whose locations are given by PDF of R and z, and
    velocities are given by interpolating rotation curve.

    Arguments:
      sdir (string): parent directory of the snapshot file or immediate
        snapshot sub-directory if it is a multi-part file

      snum (int): number of the snapshot. e.g. snapshot_001.hdf5 is '1'
        Note for multi-part files, this is just the number of the 'set', i.e. 
        if you have snapshot_001.N.hdf5, set this to '1', not 'N' or '1.N'

      ngas (int): Number of gas particles

      gas_frac(float): The mass fraction of gas particles relative to total
        disk mass

      T_gas (float): Temperature of generated gas particles

    Returns:
      loc_gas (2D ndarray): Locations of generated gas particles in Cartesian

      v_gas (2D ndarray): Velocities of generated gas particles in Cartesian

      id_gas (1D ndarray): Particle IDs of generated gas particles

      m_gas (1D ndarray): Masses of generated gas particles

      u_gas (1D ndarray): Internal energies of generated gas particles
    """

    ## Read radial scale length and scale height of the given galaxy
    fname = sdir+"/structural_constants.txt"
    file = open(fname, 'r')
    structural_constants = file.read().strip().split('\n')
    R0 = float(structural_constants[4])  ## Radial scale length
    z0 = float(structural_constants[5])  ## Scale height
    file.close()

    ## Generate positions of gas particles
    ## Generate random R corresponding to R PDF.
    R_seed = nprand.sample(ngas)
    R_list = R_PDF_integrated_inverse(R0, R_seed)
    R_list = np.sort(R_list)  ## Sorting now does not affect the result, for optimization
    ## Generate random theta (in cylindrical coordinate)
    theta_list = 2*np.pi*nprand.sample(ngas)
    loc_gas = np.vstack((R_list, theta_list))
    ## Generate random z corresponding to z PDF.
    z_seed, z_sign_seed = nprand.sample(ngas), nprand.sample(ngas)
    z_list = z_PDF_integrated_inverse(R_list, z0, z_seed)
    index = np.where(z_sign_seed <= 0.5)
    z_list[index] *= -1
    loc_gas = np.vstack((loc_gas, z_list)).T
    ## Change the coordinate system from cylindrical to Cartesian
    x = loc_gas[:,0]*np.cos(loc_gas[:,1])
    y = loc_gas[:,0]*np.sin(loc_gas[:,1])
    loc_gas[:,0], loc_gas[:,1] = x, y

    ## Generate velocities of gas particles
    ## Read rotation curve
    fname = sdir+"/rotcurve.txt"
    file = open(fname, 'r')
    file.readline()  ## Dispose of first line
    rotcurve_data = file.readline().strip().split()
    for line in file.readlines():
        rotcurve_data = np.vstack((rotcurve_data, line.strip().split()))
    R_domain = np.array(rotcurve_data[:,0], dtype=float)
    rotcurve = np.array(rotcurve_data[:,1], dtype=float)
    R_domain = np.append(0, R_domain)
    rotcurve = np.append(0, rotcurve) ## Add zero rotation velocity to center
    file.close()
    ## Assign appropriate velocities to the gas particles
    v_gas = np.zeros_like(loc_gas)
    index = np.array([], dtype=int)
    i, j = 0, 0
    for i in range(len(R_list)):  ## Remember R_list is sorted
        while R_list[i] > R_domain[j]:
            j += 1  ## Assume R_domain will cover every generated gas particlesv
        index = np.append(index, j)
    v_R = ((R_list-R_domain[index-1])*rotcurve[index] + \
           (R_domain[index]-R_list)*rotcurve[index-1]) / \
          (R_domain[index]-R_domain[index-1])  ## Interporating rotcurve
    v_x = -v_R*np.sin(theta_list)
    v_y = v_R*np.cos(theta_list)
    v_z = np.zeros_like(v_x)
    v_gas[:,0], v_gas[:,1], v_gas[:,2] = v_x, v_y, v_z

    ## Assign IDs to generated gas particles
    max_exist_ID = 0
    ptypes = [0,1,2,3,4,5]
    for ptype in ptypes:
        max_ptype_ID = np.max(load_from_snapshot('ParticleIDs', ptype, sdir, snum))
        if max_exist_ID < max_ptype_ID:
            max_exist_ID = max_ptype_ID
    id_gas = np.arange(max_exist_ID+1, max_exist_ID+ngas+1, 1, dtype=int)

    ## Assign masses to generated gas particles
    disk_mass = np.sum(load_from_snapshot('Masses', 2, sdir, snum))
    m_gas = disk_mass*gas_frac/ngas*np.ones(ngas)

    ## Assign internal energy to generaged gas particles
    u_gas = T_gas*k/mu/(gamma-1)/m_p*np.ones(len(m_gas))
    return loc_gas, v_gas, id_gas, m_gas, u_gas


def add_gas(sdir, snum, ngas, gas_frac, T_gas):
    """Add gas particles to desinated GalIC output file (HDF5 format).

    Arguments:
      sdir (string): parent directory of the snapshot file or immediate
        snapshot sub-directory if it is a multi-part file
            
      snum (int): number of the snapshot. e.g. snapshot_001.hdf5 is '1'
        Note for multi-part files, this is just the number of the 'set', i.e. 
        if you have snapshot_001.N.hdf5, set this to '1', not 'N' or '1.N'

      ngas (int): Number of gas particles

      gas_frac (float): Mass fraction of gas particles relative to total
        disk mass

      T_gas (float): Temperature of generated gas particles

    Raises:
      OSError: When rerunning code which was terminated with error after
        loading file and before file.close(). You should manually remove
        created './gas_added.hdf5' and rerun the code in this case.

    Returns: None
    """

    ## Create a new IC file
    fname = sdir+"/gas_added.hdf5"
    #temp_fname = "/home/du/gizmo/TestProblems/Test_Gas_Generation/snapshot_000.hdf5"
    file = h5py.File(fname, 'w')
    
    ## Load original GalIC output file and copy it into the new file
    h = file.create_group("Header")
    h_values = ['NumPart_ThisFile', 'NumPart_Total', 'NumPart_Total_HighWord',
                'MassTable', 'Time', 'Redshift', 'BoxSize',
                'NumFilesPerSnapshot', 'Omega0', 'OmegaLambda', 'HubbleParam',
                'Flag_Sfr', 'Flag_Cooling', 'Flag_StellarAge', 'Flag_Metals',
                'Flag_Feedback', 'Flag_DoublePrecision', 'Flag_IC_Info']
    for h_value in h_values:
        h_attrs = load_from_snapshot(h_value, 0, sdir, snum)
        if type(h_attrs) != int or h_attrs != 0:  ## Only when attributes exist in the original file
            h.attrs[h_value] = h_attrs
        else:
            print(h_value)
    ptype_candidates = np.array([0,1,2,3,4,5])
    index = np.where(h.attrs['NumPart_ThisFile'] > 0)
    ptypes = ptype_candidates[index]
    ## Edit particle data
    p_values = ['Coordinates', 'Velocities', 'ParticleIDs', 'Masses',
                'InternalEnergy']
    for ptype in ptypes:
        p = file.create_group("PartType"+str(ptype))
        for p_value in p_values:
            ## Change disk particle mass
            if ptype == 2 and p_value == 'Masses':
                ptype2_mass = load_from_snapshot(p_value, ptype, sdir, snum)
                ptype2_mass *= 1-gas_frac
                p.create_dataset(p_value, data=ptype2_mass)
            ## Use the original values for other properties
            else:
                p_attrs = load_from_snapshot(p_value, ptype, sdir, snum)
                if type(p_attrs) != int or p_attrs != 0:  # Only when attributes exist in the original file
                    p.create_dataset(p_value, data=p_attrs)

    ## Generate gas particles
    loc_gas, v_gas, id_gas, m_gas, u_gas = generate_gas(sdir, snum, ngas, gas_frac, T_gas)

    ## Add the gas particles to IC file
    npart = h.attrs['NumPart_ThisFile']
    npart[0] = ngas
    h.attrs['NumPart_ThisFile'] = npart
    h.attrs['NumPart_Total'] = npart
    p = file.create_group("PartType0")
    p.create_dataset('Coordinates', data=loc_gas)
    p.create_dataset('Velocities', data=v_gas)
    p.create_dataset('ParticleIDs', data=id_gas)
    p.create_dataset('Masses', data=m_gas)
    p.create_dataset('InternalEnergy', data=u_gas)
    
    file.close()

    return None


def make_gas_equilibrium_short_evolution(sdir, model_name, core_num):
    """This subroutine create a directory under /home/du/GIZMO/AddGas whose
    name is given by the model name. Then it moves the output IC (HDF5) file
    of the add_gas function the created directory and also copies GIZMO into
    the directory. Finally, this subroutine evolves the galaxy by GIZMO for
    10Myr with only gravitation to make the gas particle in equilibrium.

    Arguments:
      sdir (string): parent directory of the snapshot file or immediate
        snapshot sub-directory if it is a multi-part file

      model_name (string): The name of the model, will be used as the name 
        of the created directory.

      core_num (int): The number of cores that will be used to run GIZMO

    Raises:
      OSError: When you try to allocate impossible number of  cores to run
        GIZMO. Try again with lower number of cores.

    Returns: None
    """

    ## Just like bash scripting!
    cwd = os.getcwd()
    wd = '/home/du/GIZMO/AddGas/'+model_name
    os.system('rm -r '+wd)
    os.system('cp -r -f /home/du/GIZMO/AddGas/GasMaker '+wd)
    os.system('cp '+sdir+'/gas_added.hdf5 '+wd+'/gas_added.hdf5')
    os.chdir(wd)
    os.system('mpiexec -np %d ./GIZMO short_evolution.params' %core_num)
    os.system('cp results/snapshot_010.hdf5 '+model_name+'_gas_added.hdf5')
    os.chdir(cwd)
    
    return None


def make_gas_equilibrium_evolve_gas_only(sdir, model_name, core_num, end_time):
    """This subroutine create a directory under /home/du/GIZMO/AddGas whose
    name is given by the model name. Then it moves the output IC (HDF5) file
    of the add_gas function the created directory and also copies GIZMO into
    the directory. Finally, this subroutine evolves the galaxy by GIZMO for
    10Myr with only gravitation to make the gas particle in equilibrium.

    Arguments:
      sdir (string): parent directory of the snapshot file or immediate
        snapshot sub-directory if it is a multi-part file

      model_name (string): The name of the model, will be used as the name 
        of the created directory.

      core_num (int): The number of cores that will be used to run GIZMO

      end_time (float): Gas evolution time in code unit (normally Gyr)

    Raises:
      OSError: When you try to allocate impossible number of  cores to run
        GIZMO. Try again with lower number of cores.

    Returns: None
    """

    ## Just like bash scripting!
    cwd = os.getcwd()
    wd = '/home/du/GIZMO/AddGas/'+model_name
    os.system('rm -r '+wd)
    os.system('cp -r -f /home/du/GIZMO/AddGas/GasMaker '+wd)
    os.system('cp '+sdir+'/gas_added.hdf5 '+wd+'/gas_added.hdf5')
    os.chdir(wd)
    os.system('rm -r equilibrium_test')
    os.system('mkdir equilibrium_test')
    
    ## Evolve gas only by repeating: Execute GIZMO for short time
    ## -> Create new IC file with evolved gas data and original other particle data
    ## -> Repeat it until desired evolution time is reached
    save_time_list = np.arange(0, 1.01, 0.05)
    time = 0
    for save_time in save_time_list:
        if abs(save_time-time) < 1e-8:
            os.system('cp gas_added.hdf5 equilibrium_test/time_'+str(save_time)+'.hdf5')
    while time < end_time:
        os.system('mpiexec -np %d ./GIZMO evolve_gas_only.params' %core_num)
        
        ## Create new IC file with evolved gas data and original other particle data
        sdir2 = wd+"/results"
        new_file = wd+"/gas_added.hdf5"
        os.system('rm '+new_file)
        file = h5py.File(new_file, 'w')
        ## Create header
        h = file.create_group("Header")
        h_values = ['NumPart_ThisFile', 'NumPart_Total', 'NumPart_Total_HighWord',
                    'MassTable', 'Time', 'Redshift', 'BoxSize',
                    'NumFilesPerSnapshot', 'Omega0', 'OmegaLambda', 'HubbleParam',
                    'Flag_Sfr', 'Flag_Cooling', 'Flag_StellarAge', 'Flag_Metals',
                    'Flag_Feedback', 'Flag_DoublePrecision', 'Flag_IC_Info']
        for h_value in h_values:
            h_attrs = load_from_snapshot(h_value, 0, sdir2, 0)
            if type(h_attrs) != int or h_attrs != 0:  ## Only when attributes exist in the original file
                h.attrs[h_value] = h_attrs
            else:
                print(h_value)  ## For debugging purpose
        ptype_candidates = np.array([0,1,2,3,4,5])
        index = np.where(h.attrs['NumPart_ThisFile'] > 0)
        ## Create particle data
        ptypes = ptype_candidates[index]
        p_values = ['Coordinates', 'Velocities', 'ParticleIDs', 'Masses',
                    'InternalEnergy']
        for ptype in ptypes:
            p = file.create_group("PartType"+str(ptype))
            for p_value in p_values:
                ## Use evolved data for gas
                if ptype == 0:
                    p_attrs = load_from_snapshot(p_value, ptype, sdir2, 1)
                    if type(p_attrs) != int or p_attrs != 0:  # Only when attributes exist in the original file
                        p.create_dataset(p_value, data=p_attrs)
                ## Use unevolved data for other particles
                else:
                    p_attrs = load_from_snapshot(p_value, ptype, sdir2, 0)
                    if type(p_attrs) != int or p_attrs != 0:  # Only when attributes exist in the original file
                        p.create_dataset(p_value, data=p_attrs)        
        file.close()
        
        time += 0.001  ## You should change this when you change tmax in parameter file

        ## Save file for equilibrium analysis
        for save_time in save_time_list:
            if abs(save_time-time) < 1e-8:
                os.system('cp gas_added.hdf5 equilibrium_test/time_%.3f.hdf5' %save_time)

    ## Change the name of output snapshots for future analysis
    os.chdir(wd+'/equilibrium_test')
    snapshots = [f for f in os.listdir(os.getcwd())]
    snapshots.sort()
    for i in range(len(snapshots)):
        file = snapshots[i]
        if i < 10:
            os.system('mv '+file+' snapshot_00%d.hdf5' %i)
        elif i < 100:
            os.system('mv '+file+' snapshot_0%d.hdf5' %i)
        elif i < 1000:
            os.system('mv '+file+' snapshot_%d.hdf5' %i)
        else:
            ## Code should not reach here
            sys.exit("Too many output files. Adjust the number of output snpashots.")

    os.chdir(cwd)

    return None


def check_gas_velocity_before_eq(sdir, model_name):
    """Check the legitimacy of the gas velocitie by plotting gas velocities
    against its position and compare it with disk.
    
    Arguments:
      model_name (string): The name of the model, will be used as the name 
        of the created directory.

    Returns: None
    """

    ## Load gas and disk particle's location and velocities
    snum_list = np.arange(0, 21, 1, dtype=int)
    for snum in snum_list:
        if snum < 10:
            fname = sdir+"/snapshot_00%d.hdf5" %snum
        else:
            fname = sdir+"/snapshot_0%d.hdf5" %snum
        file = h5py.File(fname, 'r')
        loc_gas = np.array(file['PartType0/Coordinates/'])
        v_gas = np.array(file['PartType0/Velocities/'])
        loc_disk = np.array(file['PartType2/Coordinates/'])
        v_disk = np.array(file['PartType2/Velocities/'])
        ## Transformation from Cartesian to cylindrical
        loc_gas_R = np.sqrt(loc_gas[:,0]**2+loc_gas[:,1]**2)
        v_gas_R = np.sqrt(v_gas[:,0]**2+v_gas[:,1]**2)
        loc_disk_R = np.sqrt(loc_disk[:,0]**2+loc_disk[:,1]**2)
        v_disk_R = np.sqrt(v_disk[:,0]**2+v_disk[:,1]**2)
    
        ## Plot
        plt.plot(loc_disk_R, v_disk_R, 'r.', label='Disk', markersize=1)
        plt.plot(loc_gas_R, v_gas_R, 'b+', label='Gas', markersize=1)
        plt.xlabel('R (kpc)')
        plt.ylabel('v (km/s)')
        plt.title('R vs v plot')
        plt.legend()
        plt.show()
        
#        ## v_z
#        v_gas_z = v_gas[:,2]
#        v_disk_z = v_disk[:,2]
#        plt.plot(loc_disk_R, v_disk_z, 'r.', label='Disk', markersize=1)
#        plt.plot(loc_gas_R, v_gas_z, 'b+', label='Gas', markersize=1)
#        plt.xlabel('R (kpc)')
#        plt.ylabel('v (km/s)')
#        plt.title('R vs v plot')
#        plt.legend()
#        plt.show()
        
        file.close()

    ## Plot gas velocity direction (only for small fraction of them)
    plt.figure(figsize=(10,10))
    gas_limit = 0.5
    disk_limit = gas_limit*1.1
    num_limit = 5000
    loc_gas = loc_gas[np.where((abs(loc_gas[:,0])<gas_limit) & (abs(loc_gas[:,1])<gas_limit))]
    v_gas = v_gas[np.where((abs(loc_gas[:,0])<gas_limit) & (abs(loc_gas[:,1])<gas_limit))]
    loc_disk = loc_disk[np.where((abs(loc_disk[:,0])<disk_limit) & (abs(loc_disk[:,1])<disk_limit))]
    v_disk = v_disk[np.where((abs(loc_disk[:,0])<disk_limit) & (abs(loc_disk[:,1])<disk_limit))]
    plt.quiver(loc_disk[:num_limit,0], loc_disk[:num_limit,1],
               v_disk[:num_limit,0], v_disk[:num_limit,1],
               color='k', label='Disk')
    plt.quiver(loc_gas[:num_limit,0], loc_gas[:num_limit,1],
               v_gas[:num_limit,0], v_gas[:num_limit,1], color='c', label='Gas')
    plt.axis('equal')
    plt.title('Direction of gas particle motions (%d gas and disk particles)' %num_limit)
    plt.xlabel('x (kpc)')
    plt.ylabel('y (kpc)')
    plt.legend()
    plt.show()
    
    file.close()
    return None


def check_equilibrium(model_name, sizes=[10.], axes=[(0,1),(0,2),(1,2)]):
    """Check the equilibrium of the gas particle by plotting the location of
    gas particles in each snapshot files
    
    Arguments:
      model_name (string): The name of the model, will be used as the name 
        of the created directory.

    Optionals:
      sizes (int, float list or int, float): The size of the plot in code unit
        (nomarlly kpc - but inspect your setting!). Default value is 10,
        recommended for observing disk and bulge structures. If an user
        specifies this by passing a float number list, then it will only
        repeatedly plot the density contour within the size specified by each
        element of the list. Just passing a float number is also okay, it will
        be treated as a list of length 1.
        Special value -1 - then the size of the plot will be scaled to
        incorporate every particles.
    
      axes (tuple list or tuple): Specify the projected plane. Users
        can specify the projected plane by passing a list of tuple (or just 
        a tuple) of combination of 0 (for x-axis), 1 (for y-axis) or 2
        (for z-axis). For example, if one want to choose xy-plane, then pass
        axis=(0,1). Other values will give error and immediate return of this
        function. Default will plot all (xy,xz,yz) plane.

    Returns: None
    """

    ## Treat float of int number as a list of length 1
    if type(sizes) == float or type(sizes) == int: sizes = [sizes]
    
    ## Inspect legitimacy of size
    for size in sizes:
        if size<=0:
            print("Non-positive size is entered. Please enter positive value for the size.")

    ## Treat tuple as a list of length 1
    if type(axes) == tuple: axes = [axes]

    ## Inspect legitimacy of the format
    for axis in axes:
        if axis[0] != 0 and axis[0] !=1 and axis[0] != 2 and \
        axis[1] != 0 and axis[1] !=1 and axis[1] != 2:
            print("Please follow the format: [0, 1, 2] for [x, y, z] axis - then \
                  specify the plane by pairing axis like (0,2), in case of yz-plane.")
            return None 

    sdir = '/home/du/GIZMO/AddGas/'+model_name+'/results'
    loc_gas_t0 = load_from_snapshot('Coordinates', 0, sdir, 0)
    loc_gas_t5 = load_from_snapshot('Coordinates', 0, sdir, 5)
    loc_gas_t8 = load_from_snapshot('Coordinates', 0, sdir, 8)   
    loc_gas_t10 = load_from_snapshot('Coordinates', 0, sdir, 10)

    ## Plot galaxies within given size
    axis_label = ["X", "Y", "Z"]
    for size in sizes:
        for x_axis, y_axis in axes:

            ## Plot the gas particles
            num_limit = 10000
            plt.figure(figsize = (10,10))
            plt.axis('equal')
            plt.plot(loc_gas_t0[:num_limit,x_axis], loc_gas_t0[:num_limit,y_axis],
                     'ko', markersize=1, label="0 Myr")
            plt.plot(loc_gas_t5[:num_limit,x_axis], loc_gas_t5[:num_limit,y_axis],
                     'bo', markersize=1, label="5 Myr")
            plt.plot(loc_gas_t8[:num_limit,x_axis], loc_gas_t8[:num_limit,y_axis],
                     'ro', markersize=1, label="8 Myr")
            plt.plot(loc_gas_t10[:num_limit,x_axis], loc_gas_t10[:num_limit,y_axis], 
                     'co', markersize=1, label="10 Myr")
            x_label, y_label = axis_label[x_axis], axis_label[y_axis]
            plt.xlabel(x_label+" axis [kpc]")
            plt.ylabel(y_label+" axis [kpc]")
            plt.title("t=%.2f Gyr, projected onto %s%s-plane galaxy" %(snum*0.01, x_label, y_label))
            plt.xlim((-size, size))
            plt.ylim((-size, size))
            plt.legend()
            plt.show()

    return None


def compute_scale_height_and_length(sdir, snum):


    data = load_from_snapshot('Coordinates', 0, sdir, snum)


model_name = "Model_Bar1"
sdir = "/home/du/GIZMO/GalIC_Test/"+model_name  ## Where GalIC file is located
#sdir = "/home/du/GIZMO/AddGas/Model_Bar1_Eq_Test/height0.5_evolve1"
snum = 10
ngas = 10000
gas_frac = 0.1
T_gas = 10000.

## Actually make gas particles
add_gas(sdir, snum, ngas, gas_frac, T_gas)

## Evolve IC to reach equilibrium, choose one among 2 options
## Note that this is closely related to directory structure and paramter file.
## So if you have different directory structure or paramter file,
## you need to change the function appropriately.
#core_num = 8
#make_gas_equilibrium_short_evolution(sdir, model_name, core_num)

core_num, end_time = 12, 1
make_gas_equilibrium_evolve_gas_only(sdir, model_name, core_num, end_time)

## For checking purpose
#check_gas_velocity_before_eq(sdir, model_name)

## For checking purpose
#check_equilibrium(model_name, sizes=[1.], axes=[(0,2)])